#+TITLE: Course 332402 Computational Logics and Software Verification
#+AUTHOR: J.-A. Lin
#+OPTIONS: num:nil
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

* General Infromation
*Instructor*: Jyun-Ao Lin\\
*Location*: 科研大樓 ???\\
*Time*: 09:10 -- 12:00, ??

** Overviews
Computational logic has been used in a wide range of application in
computer science, ranging from the deductive approach to Artificial
Intelligence advocated by AI’s founder John McCarthy, to proving the
absence of bugs in large industrial software such as the 14th metro
line in Paris, or checking difficult theorems the as the one of
Feit-Thompson in the classification of finite simple groups.

The goal of this course is to explain how logic can be used in order
for modeling problems of computational or mathematical nature, and how
computers can be used to achieve this. In particular, we will present
proof assistants, which allow to formalize human reasoning by
interactively constructing proofs, and explain their use to certify
the absence of bugs in programs.


** Recommended Prerequisites
Some basic discrete mathematics, computer programming, algorithms,
theory of computation.

** Communication
When you need help from the course staff, please use office hours or
hang around after lecture. For issues requiring privacy, please feel
free to email the course instructor.
** Office Hours
TBA




* Topics and Class Schedule
** Topics
*** Propositional Logic
*** Predicate Logic
*** Model Checking
*** Program Verification

** Class Schedule

| Date  |  # | Lecture      | Support |
|-------+----+--------------+---------|
| 02/21 |  1 | Introduction |         |
| 02/26 |  2 |              |         |
| 03/04 |  3 |              |         |
| 03/11 |  4 |              |         |
| 03/18 |  5 |              |         |
| 03/25 |  6 |              |         |
| 04/01 |  7 |              |         |
| 04/08 |  8 |              |         |
| 04/15 |  9 |              |         |
| 04/22 | 10 |              |         |
| 04/29 | 11 |              |         |
| 05/06 | 12 |              |         |
| 05/13 | 13 |              |         |
| 05/20 | 14 |              |         |
| 05/27 | 15 |              |         |
| 06/03 | 16 |              |         |
| 06/10 | 17 |              |         |
| 06/17 | 18 |              |         |


* Useful References
- [[https://link.springer.com/book/10.1007%2F978-1-84882-745-5][Verification of Sequential and Concurrent Program]]
- [[https://link.springer.com/book/10.1007/978-3-662-03811-6][Principal of Program Analysis]]
- [[http://is.ifmo.ru/books/_principles_of_model_checking.pdf][Principal of Model Checking]] 
- [[http://www.springer.com/computer/theoretical+computer+science/book/978-3-540-74112-1][Calculus of Computation]]
- [[http://www.decision-procedures.org/][Decision Procedures]] 
- [[https://www.cl.cam.ac.uk/~jrh13/atp/][Handbook of Practical Logic and Automated Reasoning]] 



* Evalution
** Asseignments (50 %)
***  Written Homework:
The goal of the written homework is to help you refine the fundamental
skills, and better understand the theoretical underpinnings, that you
will need in order to do well on the labs and exams. Grading for these
assignments is based on the correctness of your answer, and the
presentation of your reasoning. You should strive for clarity and
conciseness, while making sure to show each step of your
reasoning. Categorical answers with no explanation will not even
receive partial credit, but lucid explanations of your attempt to find
the answer will.

Written homework will be handed in in PDF format via Gradescope, and
should preferably be typeset in LaTeX.
*** Programming Homework:
The programming homework is designed to give you hands-on experience
writing bug-free code with the help of formal verification tools. In
general, we will ask you to implement some interesting functionality,
such as a SAT solver or fault-tolerant communication protocol, provide
a formal specification of what it means for that functionality to be
correct, and use the appropriate tool to verify that you have
implemented it correctly. For many this is likely to be the most
challenging part of the course, but it will also be rewarding. The
experience of writing a complex program, proving it correct, and
having it work exactly as intended on the first execution (and all
subsequent ones) is exhilarating!

The most important criterion with respect to grading programs is
correctness. An ideal program attempt contains concise, correct
specifications and sufficient proof annotations for the automated
verifier to certify correctness. This will receive full credit, in
addition to pleasing the course staff as the verifier will do most of
the work in grading. However, it may be the case that your
specification is incorrect, or too complicated for the grader to fully
understand. Verification cannot be fully automated, and finding the
right annotations to provide to the tool can be challenging, so it can
happen that you do not provide a solution that the verifier can
certify (even if you implemented the functionality correctly). In
these cases, you will receive partial credit, so it is also important
that the code you hand in be clean and well-commented, as course staff
cannot assign points to solutions that they do not understand.

*** Academic Integrity
Students are expected to complete each assignment on their own, and
should be able to explain all of the work that they hand in. Copying
code or proof material from other students, from online sources, or
from prior instances of this course is not allowed. However, you are
encouraged to discuss assignments with each other at a sufficiently
high level to avoid the risk of duplicating implementation or
proof. Examples of this would be discussing algorithms and properties
referred to in the assignment, helping other students with questions
about a programming language or tool required to complete the
assignment, discussing a general proof technique, or referring to an
online source with useful information. Similarly, you may consult
online sources, tutorials, and public libraries regarding the Why3
language and the theorem provers it uses. If you find specifically
helpful material it is critical that you (a) do not copy the code or
proof, but study it as a guide and then do your own work, and (b) cite
the source with a suitable URL in your solution. If you have questions
about whether something might be permissible, contact the course staff
before you proceed.
    
** Mid-terms (20 %)
TBA
** Final Project (20 %)
TBA
** Attendance (10 %)
All students are expected to attend the lectures. However I appreciate
that different people learn differently. Thus the attendance won't be
recorded.



* Useful links
** OCaml
- [[http://ocaml.org/][OCaml]]
- [[https://caml.inria.fr/pub/docs/manual-ocaml/][OCaml's Documentation]]
- [[https://caml.inria.fr/pub/docs/manual-ocaml/libref/][OCaml's Standard Library]]
- [[https://dev.realworldocaml.org/][Real World OCaml]]: a book about OCaml from the beginning.

** Proof Assistant
- [[https://coq.inria.fr/][Coq]] ([[https://softwarefoundations.cis.upenn.edu/lf-current/toc.html][introduction to the language]])
- [[https://leanprover.github.io/][Lean]]
- [[https://wiki.portal.chalmers.se/agda/pmwiki.php][Agda]] ([[https://agda.readthedocs.io/en/latest/][Agda's documentation]])
  
** LaTeX
- [[https://www.logicmatters.net/latex-for-logicians/][LaTeX for Logicians]]

** Others
- [[https://github.com/ligurio/practical-fm][A List of companies that use formal verification methods in software engineering]]

* Credits
The course is designed based on the [[https://homepage.iis.sinica.edu.tw/~bywang/courses/comp-logic/][Introduction to Computational
Logic]] by [[https://homepage.iis.sinica.edu.tw/~bywang/][Bow-Yaw Wang]]. 
